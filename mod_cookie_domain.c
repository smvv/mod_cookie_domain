/*
**  mod_cookie_domain.c -- Apache sample cookie_domain module
**  [Autogenerated via ``apxs -n cookie_domain -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory
**  by running:
**
**    $ apxs -c -i mod_cookie_domain.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /cookie_domain in as follows:
**
**    #   apache2.conf
**    LoadModule cookie_domain_module modules/mod_cookie_domain.so
**    <Location /cookie_domain>
**    SetHandler cookie_domain
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /cookie_domain and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/cookie_domain
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**
**    The sample page from mod_cookie_domain.c
*/

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"
#include "http_log.h"
#include "apr_strmatch.h"
#include "apr_strings.h"
#include "apr_uri.h"

static apr_status_t cookie_domain_filter(ap_filter_t* f,
        apr_bucket_brigade* bb) {
    request_rec *r = f->r;
    conn_rec *c = r->connection;
    apr_bucket_brigade *bb_out = apr_brigade_create(r->pool, c->bucket_alloc);

    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "hostname=%s", r->hostname);

    // Precompile the search string
    apr_size_t cookie_pattern_len = sizeof("\r\nSet-Cookie: ") / sizeof(char);

    const apr_strmatch_pattern *cookie_pattern =
        apr_strmatch_precompile(r->pool, "\r\nSet-Cookie: ", 1);

    const apr_strmatch_pattern *delim_pattern =
        apr_strmatch_precompile(r->pool, "\r\n", 0);

    char *cookie = NULL;

    // read a chunk of data, process it, pass it to the next filter
    apr_bucket *e;

    for (e = APR_BRIGADE_FIRST(bb);
         e != APR_BRIGADE_SENTINEL(bb);
         e = APR_BUCKET_NEXT(e)) {

        const char *data;
        apr_size_t buf_len;
        char *buf;
        apr_size_t n, i;
        apr_bucket *b_out;

        if(APR_BUCKET_IS_EOS(e)) {
            apr_bucket *b_eos = apr_bucket_eos_create(c->bucket_alloc);
            APR_BRIGADE_INSERT_TAIL(bb_out, b_eos);
            break;
        }

        // Read data from bucket
        apr_bucket_read(e, &data, &buf_len, APR_BLOCK_READ);

        if (APR_BUCKET_IS_HEAP(e)) {
            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "heap: %s", data);

            // Find the 'Set-Cookie' pattern and, if that pattern is found,
            // continue with looking for the http header delimiter "\r\n". When
            // the delimiter is found, the start and end position the cookie
            // are known.
            const char *match = apr_strmatch(cookie_pattern, data, buf_len);

            apr_size_t cookie_pos = 0;
            apr_size_t cookie_len = 0;
            apr_size_t cookie_diff = 0;

            if (match) {
                const char *start_cookie = match + cookie_pattern_len - 1;
                cookie_pos = match - data + cookie_pattern_len - 1;
                apr_size_t max_len = buf_len - cookie_pattern_len - (match -
                        data);

                match = apr_strmatch(delim_pattern, start_cookie, max_len);
                if (match) {
                    cookie_len = match - start_cookie;
                    cookie = apr_pstrmemdup(r->pool, start_cookie, cookie_len);
                }
            }

            char *domain = NULL;

            // When a cookie is found, tokenize the hostname, and find the last
            // two parts of the domain name (thus only the TLD and the domain
            // name parts). When two valid parts are found, reconstruct the
            // main domain name and append "; Domain=." followed by the
            // reconstructed domain name to the cookie string.
            if (cookie) {
                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                        "found cookie: %s", cookie);

                // Duplicate hostname for tokenization
                char *hostname = apr_pstrdup(r->pool, r->hostname);

                char *parts[2] = {NULL, NULL};
                char *last, *part = apr_strtok(hostname, ".", &last);
                int p = 0;

                while(part) {
                    parts[p] = apr_pstrdup(r->pool, part);
                    p = (p + 1) % 2;
                    part = apr_strtok(NULL, ".", &last);
                }

                // TODO: check if both parts are set. Also check that the
                // domain is not an IP address, because IP addresses should not
                // be truncated to the last two parts of the IP address.

                if (p == 0)
                    domain = apr_pstrcat(r->pool, parts[0], ".", parts[1], NULL);
                else
                    domain = apr_pstrcat(r->pool, parts[1], ".", parts[0], NULL);

                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "domain=%s", domain);

                cookie = apr_pstrcat(r->pool, cookie, "; Domain=.", domain, NULL);

                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r,
                        "new cookie: %s", cookie);

                cookie_diff = strlen("; Domain=.") + strlen(domain);
                cookie_len += cookie_diff;
                buf_len += cookie_diff;
            }

            // TODO: copy bucket efficiently
            buf = apr_bucket_alloc(buf_len, c->bucket_alloc);

            for(n=0 ; n < cookie_pos; ++n)
                buf[n] = data[n];

            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "buf 1: %s", buf);

            if (cookie) {
                for(i = 0; i < cookie_len; ++i, ++n)
                    buf[n] = cookie[i];

                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "buf 2: %s", buf);
            }

            for(i = n - cookie_diff; n < buf_len; ++i, ++n)
                buf[n] = data[i];

            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "buf 3: %s", buf);
        } else {
            // TODO: copy bucket efficiently
            buf = apr_bucket_alloc(buf_len, c->bucket_alloc);
            for(n=0 ; n < buf_len ; ++n)
                buf[n] = data[n];
        }

        b_out = apr_bucket_heap_create(buf, buf_len, apr_bucket_free,
                c->bucket_alloc);
        APR_BRIGADE_INSERT_TAIL(bb_out, b_out);
    }

    apr_brigade_cleanup(bb);

    return ap_pass_brigade(f->next, bb_out);
}

static void cookie_domain_register_hooks(apr_pool_t *p) {
    // TODO: precompute search patterns on filter initialization.
    (void) p;
    ap_register_output_filter("COOKIE_DOMAIN", cookie_domain_filter,
                              NULL, AP_FTYPE_PROTOCOL);
}

static const command_rec cookie_domain_filter_cmds[] = {
    {NULL, {NULL}, NULL, 0, 0, NULL},
};

module AP_MODULE_DECLARE_DATA cookie_domain_module = {
    STANDARD20_MODULE_STUFF,
    NULL,                      /* create per-dir    config structures */
    NULL,                      /* merge  per-dir    config structures */
    NULL,                      /* create per-server config structures */
    NULL,                      /* merge  per-server config structures */
    cookie_domain_filter_cmds, /* table of config file commands       */
    cookie_domain_register_hooks
};
